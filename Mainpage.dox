/**
\mainpage %Akonadi Server

<p><b>
Overview |
\ref akonadi_server_definitions |
\ref akonadi_server_srclayout
</b></p>

Akonadi aims to be an extensible cross-desktop storage service for PIM data
and meta data providing concurrent read, write, and query access.
It provides unique desktop-wide object identification and retrieval.

This is the API documentation for the Akonadi server.  If you are using Akonadi
from within KDE, you almost certainly want the
<a href="http://api.kde.org/4.x-api/kdepimlibs-apidocs/akonadi/html/index.html">KDE client library documentation</a>.
This API reference is more useful to people implementing client libraries or
working on the Akonadi server itself.

For additional information, see the <a href="http://www.akonadi-project.org/">Akonadi website</a>.

\section akonadi_server_architecture Architecture

<img src="http://pim.kde.org/akonadi/architecture.png"/>

The Akonadi framework uses a client/server architecture. The Akonadi server has the following primary tasks:
\li Abstract access to data from arbitrary sources, using toolkit-agnostic protocols and data formats
\li Provide a data cache shared among several clients
\li Provide change notifications and conflict detection
\li Support offline change recording and change replay for remote data

\subsection akonadi_server_components Components

The Akonadi server itself consists of a number of components:
\li The Akonadi control process (\c akonadi_control). It is responsible for managing all other server components
and Akonadi agents.
\li The Akonadi server process (\c akonadiserver). The actual data access and caching server.
\li The Akonadi agent server (\c akonadi_agent_server). Allows running of multiple Akonadi agents in one process.
\li The Akonadi agent launcher (\c akonadi_agent_launcher). A helper process for running Akonadi agents.
\li The Akonadi control tool (\c akonadictl). A tool to start/stop/restart the Akonadi server system and query its status.
    This is the only program of these listed here you should ever run manually.
\li The Akonadi protocol library (\c libakonadiprotocolinternals), Contains protocol definitions and protocol parsing methods
    useful for client implementations.

\section akonadi_server_objects Objects and Data Types

The %Akonadi server operates on two basic object types, calles items and collections. They are comparable to files and directories
and are described in more detail in this section.

\subsection akonadi_server_objects_items %Akonadi Items

An item is a generic container for whatever you want to store in Akonadi (eg. mails,
events, contacts, etc.). An item consists of some generic information (such as identifier,
mimetype, change date, flags, etc.) and a set of data fields, the item parts. Items
are independent of the type of stored data, the semantics of the actual content is only
known on the client side.

\subsubsection akonadi_server_objects_items_parts Item Parts

%Akonadi items can have one or more parts, e.g. an email message consists of the
envelope, the body and possible one or more attachments. Item parts are identified
by an identifier string. There are a few special pre-defined part identifiers (ALL,
ENVELOPE, etc.), but in general the part identifiers are definied by the type specific
extensions (ie. resource, serializer plugin, type specific client library).

\subsubsection akonadi_server_objects_items_serializer Payload Data Serialization

Item payload data is typically serialized in a standard format to ensure interoperability between different
client library implementations. However, the %Akonadi server does not enforce any format,
payload data is handled as an opaque binary blob.

\subsection akonadi_server_objects_collections Collections

Collections are sets of items. Every item is stored in exactly one
collection, this is sometimes also referred to as the "physical" storage location of the item.
An item might also be visible in several other collections - so called "virtual collections" -
which are defined as the result set of a search query.

Collections are organized hierarchically, i.e. a collection can have child
collections, thus defining a collection tree.

Collections are uniquely identified by their identifier in
contrast to their path, which is more robust wrt. to renaming and moving.

\subsubsection akonadi_server_objects_collections_akonadi Collection Properties

Every collection has a set of supported content types.
These are the mimetypes of items the collection can contain.
Example: A collection of a folder-less iCal file resource would only support
"text/calendar" items, a folder on an IMAP server "message/rfc822" but also
"inode/directory" if it can contain sub-folders.

There is a cache policy associated with every collection which defines how much
of its content should be kept in the local cache and for how long.

Additionally, collections can contain an arbitrary set of attributes to represent
various other collection properties such as ACLs, quotas or backend-specific data
used for incremental synchronization. Evaluation of such attributes is the responsibility
of client implementations, the %Akonadi server does not interpret properties
other than content types and cache policies.

\subsubsection akonadi_server_objects_collections_tree Collection Tree

There is a single collection tree in Akonadi, consisting of several parts:

- A root node, id 0
- One or more top-level collections for each resource. Think of these as mount-points
  for the resource. The resources must put their items and sub-collections into their
  corresponding top-level collection.
- Resource-dependent sub-collections below the resource top-level collections.
  If the resource represents data that is organized in folders (e.g. an IMAP
  resource), it can create additional collections below its top-level
  collection. These have to be synched with the corresponding backend by the
  resource.
  Resources which represent folder-less data (e.g. an iCal file) don't need
  any sub-collections and put their items directly into the top-level collection.
- A top-level collection containing virtual collections.

Example:

\verbatim
+-+ resource-folder1
| +- sub-folder1
| +- sub-folder2
|  ...
+-+ resource-folder2
| ...
|
+-+ Searches
  +- search-folder1
  +- search-folder2
  ...
\endverbatim


\subsection akonadi_server_objects_identification Object Identification

\subsubsection akonadi_server_objects_identification_uid Unique Identifier

Every object stored in %Akonadi (collections and items) has a unique
identifier in the form of an integer value. This identifier cannot be changed in
any way and will stay the same, regardless of any modifications to the referred
object. A unique identifier will never be used twice and is globally unique,
therefore it is possible to retrieve an item without knowing the collection it belongs to.

\subsubsection akonadi_server_objects_identification_rid Remote Identifier

Every object can also have an optional so-called remote identifier. This is an
identifier used by the corresponding resource to identify the object on its
backend (e.g., a groupware server).

The remote identifier can be changed by the owning resource agent only.


\section akonadi_server_protocols Communication Protocols

For communication within the Akonadi server infrastructure and for communication with Akonadi clients, two communication technologies are used:
\li \em D-Bus Used for management tasks and change notifications.
\li \em ASAP (Akonadi Server Access Protocol), used for high-throughput data transfer

\todo add protocol documentation

\section akonadi_server_storage Data and Metadata Storage

The Akonadi server uses two mechanisms for data storage:
\li A SQL databases for metadata and small payload data
\li Plain files for large payload data

More details on the SQL database layout can be found here: \ref akonadi_server_database.

The following SQL databases are supported by the Akonadi server:
\li \em MySQL using the default QtSQL driver shipped with Qt
\li \em Sqlite using the improved QtSQL driver shipped with the Akonadi server
\li [Experimental] \em PostgreSQL using the default QtSQL driver shipped with Qt

For details on how to configure the various backends, see Akonadi::DataStore.




\page akonadi_server_definitions Type Definitions

<p><b>
\ref index "Overview" |
\ref Type Definitions |
\ref akonadi_server_srclayout
</b></p>

To let all components play together nicely, we have to use some common encoding
definitions.

\li <em>Collection names</em><br>
    Collection names and paths are Unicode strings (QString) to allow custom names by the user.
\li <em>Data references</em><br>
    The persistent identifier is an unsigned integer and the external URL is
    a Unicode string (QString).
\li <em>Transferred data over IMAP</em><br/>
    The data transferred over IMAP are byte arrays (QByteArray). If Unicode strings are
    transferred over IMAP, UTF-8 encoding is applied.
\li <em>Error and status messages</em><br>
    Error and status messages are visible to the user, so they have to be
    Unicode strings (QString).




\page akonadi_server_srclayout Source Code Layout

<p><b>
\ref index "Overview" |
\ref akonadi_server_definitions |
\ref Source Code Layout
</b></p>

The code of the storage and control components is located in the \c server sub-directory.
The different parts are layed out as follows:

<ul>
<li> \e control <br>
    Contains the source code of the \ref akonadi_design_control "control" component.
<li> \e interfaces <br>
    Contains the D-Bus interface descriptions of the Akonadi components
<li> \e src <br>
    Contains the source code of the \ref akonadi_design_storage "storage" component.
<li> \e src/handler <br>
    Contains the source code for the handlers of the single IMAP commands.
    See <a href="group__akonadi__server__handler.html">command handlers module</a>
<li> \e src/storage <br>
    Contains the source code for accessing the storage back-end.<br>
    <ul>
    <li>  entity.{h,cpp} <br>
        The files contain classes which reflect records in the tables of the database.
        They are genreted by XLS transformation from akonadidb.xml and entities.xsl
    <li> datastore.{h,cpp} <br>
        The files contain a class which provides the access to the underlaying database tables.
    </ul>
</ul>
*/

// DOXYGEN_EXCLUDE = sqlplugin server/control server/akonadictl server/tests
// DOXYGEN_PROJECTNAME=Akonadi
// DOXYGEN_PROJECTVERSION=1.4.52

// vim:ts=4:sw=4:expandtab:filetype=doxygen
